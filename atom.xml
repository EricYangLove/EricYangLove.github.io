<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Afar</title>
  
  <subtitle>A new way to explore the world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangmj.xin/"/>
  <updated>2018-04-25T10:14:05.823Z</updated>
  <id>https://yangmj.xin/</id>
  
  <author>
    <name>Eric Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket代理</title>
    <link href="https://yangmj.xin/2017/10/25/WebSocket/"/>
    <id>https://yangmj.xin/2017/10/25/WebSocket/</id>
    <published>2017-10-25T02:49:33.000Z</published>
    <updated>2018-04-25T10:14:05.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocket代理"><a href="#WebSocket代理" class="headerlink" title="WebSocket代理"></a>WebSocket代理</h2><p>要将客户机和服务器之间的连接从HTTP / 1.1转换为WebSocket，使用HTTP / 1.1中可用的 <a href="https://tools.ietf.org/html/rfc2616#section-14.42" target="_blank" rel="external">协议切换</a> 机制。</p><p>然而，有一个微妙的地方：由于“升级”是一个 <a href="https://tools.ietf.org/html/rfc2616#section-13.5.1" target="_blank" rel="external">逐跳</a> 标题，它不会从客户端传递到代理的服务器。使用转发代理，客户端可以使用该CONNECT 方法来规避此问题。然而，这不适用于反向代理，因为客户端不知道任何代理服务器，并且需要在代理服务器上进行特殊处理。</p><p>1.3.13版本以来，nginx实现了特殊的操作模式，如果代理的服务器使用代码101（交换协议）返回响应，则客户机和代理服务器之间建立隧道，客户端通过请求中的“升级”头。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span> /chat/ &#123;</div><div class="line">    <span class="attribute">proxy_pass</span> http://backend;</div><div class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上所述，包括“升级”和“连接”的逐跳报头不会从客户端传递到代理服务器，因此为了使代理的服务器知道客户端将协议切换到WebSocket的意图，这些头文件必须明确地通过：</p><pre><code>location /chat/ {    proxy_pass http://backend;    proxy_http_version 1.1;    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;upgrade&quot;;}</code></pre><a id="more"></a><p>一个更复杂的例子，其中对代理服务器的请求中的“连接”头字段的值取决于客户端请求头中的“升级”字段的存在：</p><pre><code>http {    map $http_upgrade $connection_upgrade {        default upgrade;        &apos;&apos;      close;    }    server {        ...        location /chat/ {            proxy_pass http://backend;            proxy_http_version 1.1;            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection $connection_upgrade;        }    }</code></pre><p>默认情况下，如果代理的服务器在60秒内没有传输任何数据，则连接将被关闭。这个超时可以通过 <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout" target="_blank" rel="external">proxy_read_timeout</a> 指令来增加 。或者，代理服务器可以配置为定期发送WebSocket ping帧以重置超时并检查连接是否仍然存在。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 海尔云贷前台合同管理-合同签署-下一步-调用申请信息补充接口</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param request</span></div><div class="line"><span class="comment"> * @return</span></div><div class="line"><span class="comment"> * @throws Exception</span></div><div class="line"><span class="comment"> */</span></div><div class="line">@RequestMapping(value = <span class="string">"/mine/applyInfoInvoke.do"</span>)</div><div class="line"><span class="keyword">public</span> @ResponseBody <span class="keyword">String</span> applyInfoInvoke(HttpServletRequest request)</div><div class="line"><span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line"><span class="keyword">JSONObject</span> retObj = <span class="keyword">new</span> <span class="keyword">JSONObject</span>();</div><div class="line"></div><div class="line">Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; parMap = <span class="keyword">super</span>.getParameterMap(request);</div><div class="line"><span class="comment">// &lt;----------------------银行卡bin三要素校验/绑卡接口-------------------------&gt;</span></div><div class="line"><span class="keyword">JSONObject</span> obj = haierService.doCardBinCheck(parMap);</div><div class="line"><span class="keyword">String</span> flag = obj.getString(<span class="string">"flag"</span>);</div><div class="line"><span class="keyword">if</span> (<span class="string">"2"</span>.equals(flag) || <span class="string">"3"</span>.equals(flag) || <span class="string">"4"</span>.equals(flag)) &#123;</div><div class="line"><span class="keyword">return</span> getResponseMessage(<span class="keyword">false</span>, obj.getString(<span class="string">"message"</span>));</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"1"</span>.equals(flag)) &#123;</div><div class="line"><span class="comment">// &lt;---------------------申请信息补充接口-------------------------&gt;</span></div><div class="line">retObj = haierService.doApplyInfoSupply(parMap);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> retObj.toJSONString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WebSocket代理&quot;&gt;&lt;a href=&quot;#WebSocket代理&quot; class=&quot;headerlink&quot; title=&quot;WebSocket代理&quot;&gt;&lt;/a&gt;WebSocket代理&lt;/h2&gt;&lt;p&gt;要将客户机和服务器之间的连接从HTTP / 1.1转换为WebSocket，使用HTTP / 1.1中可用的 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.42&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;协议切换&lt;/a&gt; 机制。&lt;/p&gt;
&lt;p&gt;然而，有一个微妙的地方：由于“升级”是一个 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.5.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;逐跳&lt;/a&gt; 标题，它不会从客户端传递到代理的服务器。使用转发代理，客户端可以使用该CONNECT 方法来规避此问题。然而，这不适用于反向代理，因为客户端不知道任何代理服务器，并且需要在代理服务器上进行特殊处理。&lt;/p&gt;
&lt;p&gt;1.3.13版本以来，nginx实现了特殊的操作模式，如果代理的服务器使用代码101（交换协议）返回响应，则客户机和代理服务器之间建立隧道，客户端通过请求中的“升级”头。&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;location&lt;/span&gt; /chat/ &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;proxy_pass&lt;/span&gt; http://backend;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;proxy_http_version&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;proxy_set_header&lt;/span&gt; Upgrade &lt;span class=&quot;variable&quot;&gt;$http_upgrade&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;proxy_set_header&lt;/span&gt; Connection &lt;span class=&quot;string&quot;&gt;&quot;upgrade&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上所述，包括“升级”和“连接”的逐跳报头不会从客户端传递到代理服务器，因此为了使代理的服务器知道客户端将协议切换到WebSocket的意图，这些头文件必须明确地通过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /chat/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &amp;quot;upgrade&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://yangmj.xin/categories/Java/"/>
    
    
      <category term="Socket" scheme="https://yangmj.xin/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>配置HTTPS服务器</title>
    <link href="https://yangmj.xin/2017/10/25/hello/"/>
    <id>https://yangmj.xin/2017/10/25/hello/</id>
    <published>2017-10-25T02:48:17.000Z</published>
    <updated>2018-04-24T14:46:05.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置HTTPS服务器"><a href="#配置HTTPS服务器" class="headerlink" title="配置HTTPS服务器"></a>配置HTTPS服务器</h2><p>要配置HTTPS服务器，ssl必须在 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#server" target="_blank" rel="external">服务器</a> 块中的 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank" rel="external">侦听套接字</a> 上启用该参数 ，并且 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate" target="_blank" rel="external">应指定服务器证书</a> 和 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key" target="_blank" rel="external">私钥</a> 文件的位置 ：</p><pre><code>server {    listen              443 ssl;    server_name         www.example.com;    ssl_certificate     www.example.com.crt;    ssl_certificate_key www.example.com.key;    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers         HIGH:!aNULL:!MD5;    ...}</code></pre><a id="more"></a><p>服务器证书是一个公共实体。它被发送到连接到服务器的每个客户端。私钥是一个安全实体，应该存储在一个受限访问的文件中，但是它必须是nginx的主进程可读的。私钥可以替代地存储在与证书相同的文件中：  </p><pre><code>ssl_certificate     www.example.com.cert;ssl_certificate_key www.example.com.cert;</code></pre><p>在这种情况下，文件访问权限也应该被限制。虽然证书和密钥存储在一个文件中，但只有证书被发送到客户端。<br>指令 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_protocols" target="_blank" rel="external">ssl_protocols</a> 和 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_ciphers" target="_blank" rel="external">ssl_ciphers </a> 可用于限制连接以仅包含SSL / TLS的强大版本和密码。默认情况下，nginx使用“ ssl_protocols TLSv1 TLSv1.1 TLSv1.2”和“ ssl_ciphers HIGH:!aNULL:!MD5”，因此通常不需要明确配置它们。请注意，这些指令的默认值已 更改多次。  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">adfadsfasdfadf</span></div></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen              <span class="number">443</span> ssl<span class="comment">;</span></div><div class="line">    server_name         www.example.com<span class="comment">;</span></div><div class="line">    ssl_certificate     www.example.com.crt<span class="comment">;</span></div><div class="line">    ssl_certificate_key www.example.com.key<span class="comment">;</span></div><div class="line">    ssl_protocols       TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span><span class="comment">;</span></div><div class="line">    ssl_ciphers         HIGH:!aNULL:!MD5<span class="comment">;</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="HTTPS服务器优化"><a href="#HTTPS服务器优化" class="headerlink" title="HTTPS服务器优化"></a>HTTPS服务器优化</h3><p>SSL操作会占用更多的CPU资源。在多处理器系统上， 应该运行几个 <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes" target="_blank" rel="external">工作进程</a>，不少于可用CPU内核的数量。最多的CPU密集型操作是SSL握手。有两种方法可以最大程度地减少每个客户端的这些操作数量：首先是通过使 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_timeout" target="_blank" rel="external">Keepalive</a> 连接通过一个连接发送多个请求，第二个是重用SSL会话参数，以避免并行和后续连接的SSL握手。会话存储在工作人员共享的SSL会话高速缓存中，并由<a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_cache" target="_blank" rel="external">ssl_session_cache</a> 指令配置 。一兆字节的缓存包含约4000个会话。默认缓存超时时间为5分钟。它可以通过使用增加 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_timeout" target="_blank" rel="external">ssl_session_timeout</a> 指令。以下是针对具有10兆字节共享会话缓存的多核系统优化的示例配置：   </p><pre><code>worker_processes auto;http {    ssl_session_cache   shared:SSL:10m;    ssl_session_timeout 10m;    server {        listen              443 ssl;        server_name         www.example.com;        keepalive_timeout   70;        ssl_certificate     www.example.com.crt;        ssl_certificate_key www.example.com.key;        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;        ssl_ciphers         HIGH:!aNULL:!MD5;        ...</code></pre><h3 id="SSL证书链"><a href="#SSL证书链" class="headerlink" title="SSL证书链"></a>SSL证书链</h3><p>有些浏览器可能会抱怨知名证书颁发机构签发的证书，而其他浏览器可能会接受证书而没有问题。发生这种情况是因为颁发机构已使用特定浏览器分发的知名可信证书颁发机构的证书库中不存在的中间证书来签署服务器证书。在这种情况下，权限提供了一系列链接的证书，这些证书应该连接到签名的服务器证书。服务器证书必须出现在组合文件中的链接证书之前：  </p><pre><code>$ cat www.example.com.crt bundle.crt &gt; www.example.com.chained.crt</code></pre><p>生成的文件应该在 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate" target="_blank" rel="external">ssl_certificate</a> 指令中使用：  </p><pre><code>server {    listen              443 ssl;    server_name         www.example.com;    ssl_certificate     www.example.com.chained.crt;    ssl_certificate_key www.example.com.key;    ...}</code></pre><p>如果服务器证书和捆绑包以错误的顺序连接，nginx将无法启动并显示错误消息：  </p><pre><code>SSL_CTX_use_PrivateKey_file(&quot; ... /www.example.com.key&quot;) failed   (SSL: error:0B080074:x509 certificate routines:    X509_check_private_key:key values mismatch)</code></pre><p>因为nginx已尝试使用私钥使用捆绑包的第一个证书而不是服务器证书。  </p><p>浏览器通常存储他们收到的中间证书，哪些由受信任的机构签名，所以主动使用的浏览器可能已经具有所需的中间证书，并且可能不会抱怨没有链接捆绑包发送的证书。为了确保服务器发送完整的证书链，openssl可以使用命令行实用程序，例如：  </p><pre><code>$ openssl s_client -connect www.godaddy.com:443...Certificate chain 0 s:/C=US/ST=Arizona/L=Scottsdale/1.3.6.1.4.1.311.60.2.1.3=US     /1.3.6.1.4.1.311.60.2.1.2=AZ/O=GoDaddy.com, Inc     /OU=MIS Department/CN=www.GoDaddy.com     /serialNumber=0796928-7/2.5.4.15=V1.0, Clause 5.(b)   i:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.     /OU=http://certificates.godaddy.com/repository     /CN=Go Daddy Secure Certification Authority     /serialNumber=07969287 1 s:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.     /OU=http://certificates.godaddy.com/repository     /CN=Go Daddy Secure Certification Authority     /serialNumber=07969287   i:/C=US/O=The Go Daddy Group, Inc.     /OU=Go Daddy Class 2 Certification Authority 2 s:/C=US/O=The Go Daddy Group, Inc.     /OU=Go Daddy Class 2 Certification Authority   i:/L=ValiCert Validation Network/O=ValiCert, Inc.     /OU=ValiCert Class 2 Policy Validation Authority     /CN=http://www.valicert.com//emailAddress=info@valicert.com...</code></pre><p>在该示例中，服务器证书＃0 的主体（“ s ”） www.GoDaddy.com由发行人（“ i ”）签名，发行人本身是证书＃1的主体，由发行人本身是​​主体证书＃2，由知名发行人ValiCert，Inc.签署， 其证书存储在浏览器的内置证书库（位于Jack建造的房屋中）。  </p><p>如果未添加证书包，则仅显示服务器证书＃0。  </p><h3 id="单个HTTP-HTTPS服务器"><a href="#单个HTTP-HTTPS服务器" class="headerlink" title="单个HTTP / HTTPS服务器"></a>单个HTTP / HTTPS服务器</h3><p>可以配置一个处理HTTP和HTTPS请求的单个服务器：  </p><pre><code>server {    listen              80;    listen              443 ssl;    server_name         www.example.com;    ssl_certificate     www.example.com.crt;    ssl_certificate_key www.example.com.key;    ...}</code></pre><p>在0.7.14之前，无法为各个监听套接字选择性地启用SSL，如上所示。只能使用 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl" target="_blank" rel="external">ssl</a> 指令为整个服务器启用 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl" target="_blank" rel="external">SSL</a>，从而无法设置单个HTTP / HTTPS服务器。添加ssl了 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank" rel="external">listen</a> 指令的参数 来解决这个问题。因此，在现代版本中使用 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl" target="_blank" rel="external">ssl</a> 指令是不鼓励的。  </p><h3 id="基于名称的HTTPS服务器"><a href="#基于名称的HTTPS服务器" class="headerlink" title="基于名称的HTTPS服务器"></a>基于名称的HTTPS服务器</h3><p>配置两个或多个HTTPS服务器侦听单个IP地址时，会出现常见问题：  </p><pre><code>server {    listen          443 ssl;    server_name     www.example.com;    ssl_certificate www.example.com.crt;    ...}server {    listen          443 ssl;    server_name     www.example.org;    ssl_certificate www.example.org.crt;    ...}</code></pre><p>使用此配置，浏览器接收默认服务器的证书，即www.example.com不管所请求的服务器名称如何。这是由SSL协议行为引起的。在浏览器发送HTTP请求之前建立SSL连接，并且nginx不知道请求的服务器的名称。因此，它只能提供默认服务器的证书。  </p><p>解决问题的最古老和最强大的方法是为每个HTTPS服务器分配一个单独的IP地址：  </p><pre><code>server {    listen          192.168.1.1:443 ssl;    server_name     www.example.com;    ssl_certificate www.example.com.crt;    ...}server {    listen          192.168.1.2:443 ssl;    server_name     www.example.org;    ssl_certificate www.example.org.crt;    ...}</code></pre><h3 id="具有多个名称的SSL证书"><a href="#具有多个名称的SSL证书" class="headerlink" title="具有多个名称的SSL证书"></a>具有多个名称的SSL证书</h3><p>还有其他方法允许在多个HTTPS服务器之间共享一个IP地址。然而，他们都有自己的缺点。一种方法是在SubjectAltName证书字段中使用具有多个名称的证书，例如 www.example.com和www.example.org。但是，SubjectAltName字段长度有限。  </p><p>另一种方法是使用通配符名称的证书，例如 <em>.example.org。通配符证书保护指定域的所有子域，但只能在一个级别上。该证书相匹配www.example.org，但不匹配 example.org和www.sub.example.org。这两种方法也可以组合使用。证书可以在SubjectAltName字段中包含精确和通配符名称，例如 example.org和</em>.example.org。  </p><p>最好将几个名称的证书文件和其配置的http级别的私钥文件放在所有服务器中继承其单个内存副本：  </p><pre><code>ssl_certificate     common.crt;ssl_certificate_key common.key;server {    listen          443 ssl;    server_name     www.example.com;    ...}server {    listen          443 ssl;    server_name     www.example.org;    ...}</code></pre><h3 id="服务器名称指示"><a href="#服务器名称指示" class="headerlink" title="服务器名称指示"></a>服务器名称指示</h3><p>在单个IP地址上运行多个HTTPS服务器的更通用的解决方案是 <a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="external">TLS服务器名称指示扩展</a>（SNI，RFC 6066），允许浏览器在SSL握手期间传递所请求的服务器名称，因此服务器将知道哪个它应该用于连接的证书。 大多数现代浏览器目前都 <a href="http://en.wikipedia.org/wiki/Server_Name_Indication#Support" target="_blank" rel="external">支持</a> SNI ，尽管可能不会被某些旧的或特殊的客户端使用。  </p><pre><code>只有域名可以在SNI中传递，但是如果请求包含文字IP地址，某些浏览器可能会错误地将服务器的IP地址作为其名称传递。不应该依赖这个。</code></pre><p>为了在nginx中使用SNI，必须在已经构建了nginx二进制文件的OpenSSL库以及在运行时被动态链接的库中支持它。如果使用配置选项“–enable-tlsext”构建，则OpenSSL支持SNI，因为0.9.8f版本 。 由于OpenSSL 0.9.8j此选项默认启用。如果nginx是用SNI支持构建的，那么当使用“-V”开关运行时，nginx会显示这个：  </p><pre><code>$ nginx -V...TLS SNI support enabled...    </code></pre><p>然而，如果SNI启用的nginx与没有SNI支持的OpenSSL库动态链接，则nginx会显示警告：  </p><pre><code>nginx was built with SNI support, however, now it is linkeddynamically to an OpenSSL library which has no tlsext support,therefore SNI is not available</code></pre><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul><li>SNI支持状态由“-V”开关显示为0.8.21和0.7.62。</li><li>从0.7.14开始，支持 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen" target="_blank" rel="external">listen</a> 指令 的ssl参数 。在0.8.21之前，只能与参数一起指定 。 default</li><li>自0.5.23以来，SNI得到了支持。</li><li>从0.5.6起，共享的SSL会话缓存已被支持。</li><li>版本1.9.1及更高版本：默认SSL协议为TLSv1，TLSv1.1和TLSv1.2（如果OpenSSL库支持）。</li><li>版本0.7.65，0.8.19及更高版本：默认SSL协议是SSLv3，TLSv1，TLSv1.1和TLSv1.2（如果OpenSSL库支持）。</li><li>版本0.7.64，0.8.18及更早版本：默认SSL协议为SSLv2，SSLv3和TLSv1。</li><li>版本1.0.5及更高版本：默认SSL密码为“ HIGH:!aNULL:!MD5”。</li><li>版本0.7.65，0.8.20及更高版本：默认SSL密码为“ HIGH:!ADH:!MD5”。</li><li>版本0.8.19：默认SSL密码为“ ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM”。</li><li>版本0.7.64，0.8.18及更早版本：默认SSL密码为<br>“ ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置HTTPS服务器&quot;&gt;&lt;a href=&quot;#配置HTTPS服务器&quot; class=&quot;headerlink&quot; title=&quot;配置HTTPS服务器&quot;&gt;&lt;/a&gt;配置HTTPS服务器&lt;/h2&gt;&lt;p&gt;要配置HTTPS服务器，ssl必须在 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#server&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;服务器&lt;/a&gt; 块中的 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;侦听套接字&lt;/a&gt; 上启用该参数 ，并且 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;应指定服务器证书&lt;/a&gt; 和 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;私钥&lt;/a&gt; 文件的位置 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="HTTPS" scheme="https://yangmj.xin/categories/HTTPS/"/>
    
    
      <category term="随笔" scheme="https://yangmj.xin/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
